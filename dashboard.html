<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>作業ダッシュボード</title>
    <style>
        body {
            font-family: "Helvetica Neue", Arial, "Hiragino Kaku Gothic ProN", "Hiragino Sans", Meiryo, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f0f2f5;
            color: #333;
        }

        h1 {
            text-align: center;
            margin-bottom: 20px;
        }

        .controls {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            flex-wrap: wrap;
            justify-content: center;
        }

        button {
            padding: 10px 15px;
            cursor: pointer;
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 4px;
            font-size: 14px;
        }

        button:hover {
            background-color: #0056b3;
        }
        
        button:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
            opacity: 0.6;
        }

        .dashboard-container {
            display: flex;
            gap: 20px;
            flex-direction: column; /* Mobile friendly by default, can be row on large screens if needed, but vertical stack is safer for rows */
        }
        
        @media (min-width: 1024px) {
             .dashboard-layout {
                display: grid;
                grid-template-columns: 250px 1fr; /* Sidebar for name tags, Main area for work items */
                gap: 20px;
             }
        }

        /* Name Tag Section (Sidebar) */
        .name-tag-section {
            background: white;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            height: fit-content;
        }

        .name-tag-container {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            min-height: 100px;
            border: 2px dashed #ddd;
            padding: 10px;
            border-radius: 4px;
            align-content: flex-start;
        }

        .name-tag {
            padding: 8px 12px;
            background-color: #e0e0e0;
            border-radius: 20px;
            cursor: grab;
            user-select: none;
            font-size: 14px;
            font-weight: bold;
            display: flex;
            align-items: center;
            gap: 5px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.2);
            position: relative;
        }

        .name-tag:active {
            cursor: grabbing;
        }

        .name-tag input.color-picker {
            width: 15px;
            height: 15px;
            padding: 0;
            border: none;
            cursor: pointer;
            background: none;
        }
        
        .name-tag span {
            outline: none;
        }

        .delete-btn {
            margin-left: 5px;
            color: #888;
            cursor: pointer;
            font-size: 12px;
        }
        .delete-btn:hover {
            color: red;
        }

        /* Work Item Section */
        .work-items-section {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .work-item-row {
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            padding: 15px;
            display: flex;
            align-items: center;
            gap: 15px;
            transition: background-color 0.3s;
        }
        
        .row-controls {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        
        .row-btn {
            background: #eee;
            color: #333;
            padding: 5px;
            font-size: 12px;
            width: 30px;
            text-align: center;
        }
        
        .row-btn:hover {
            background: #ccc;
        }

        .work-item-title {
            width: 150px;
            font-weight: bold;
            font-size: 16px;
            padding: 5px;
            border: 1px solid transparent;
        }
        
        .work-item-title:hover {
            border: 1px dashed #ccc;
        }
        
        .work-item-title:focus {
            border: 1px solid #007bff;
            background: #fff;
        }

        .stages-container {
            display: flex;
            flex: 1;
            align-items: center;
            gap: 5px;
            overflow-x: auto;
        }

        .stage {
            flex: 1;
            min-width: 150px;
            background-color: #f8f9fa;
            border: 2px solid #e9ecef;
            border-radius: 6px;
            padding: 10px;
            min-height: 80px;
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .stage-header {
            font-size: 12px;
            color: #666;
            text-align: center;
            margin-bottom: 5px;
            font-weight: bold;
        }

        .stage-content {
            flex: 1;
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
            align-content: flex-start;
        }
        
        .arrow {
            font-size: 20px;
            color: #bbb;
            font-weight: bold;
        }
        
        .color-picker-wrapper {
            position: relative;
        }
        
        /* Dragging styles */
        .dragging {
            opacity: 0.5;
        }
        
        .drag-over {
            background-color: #e3f2fd;
            border-color: #2196f3;
        }

    </style>
</head>
<body>

    <h1>作業ダッシュボード</h1>

    <div class="controls" style="justify-content: center;">
        <button id="undoBtn" onclick="undo()" disabled style="background-color: #6c757d;">元に戻す (Undo)</button>
    </div>

    <div class="dashboard-layout">
        <!-- Name Tags Sidebar -->
        <div class="name-tag-section">
            <h3>名札 (人員)</h3>
            <div class="controls">
                <button onclick="addNameTag()">名札を追加</button>
                <button onclick="resetNameTags()" style="background-color: #6c757d;">配置リセット</button>
            </div>
            <div id="nameTagPool" class="name-tag-container" ondrop="drop(event)" ondragover="allowDrop(event)">
                <!-- Tags will be added here -->
            </div>
        </div>

        <!-- Work Items Main Area -->
        <div class="work-items-section">
            <div class="controls" style="justify-content: flex-start;">
                <button onclick="addWorkItem()">作業項目を追加</button>
                <button onclick="resetWorkItems()" style="background-color: #dc3545;">作業全消去</button>
            </div>
            <div id="workItemsContainer">
                <!-- Work Item Rows will be added here -->
            </div>
        </div>
    </div>

    <script>
        // --- Data & State Management ---
        let tagIdCounter = 0;
        let workItemIdCounter = 0;
        const STORAGE_KEY = 'workingDashboardData';
        
        // --- Undo Functionality ---
        const undoHistory = [];
        const MAX_HISTORY = 50; // 最大50件の履歴を保持
        
        // --- Undo Functions ---
        function captureState() {
            try {
                const data = {
                    tagIdCounter: tagIdCounter,
                    workItemIdCounter: workItemIdCounter,
                    nameTags: [],
                    workItems: []
                };
                
                // Capture all name tags
                document.querySelectorAll('.name-tag').forEach(tag => {
                    const nameSpan = tag.querySelector('span[contenteditable]');
                    const colorInput = tag.querySelector('input[type="color"]');
                    const parentId = tag.parentElement.id || tag.closest('.stage-content')?.parentElement?.parentElement?.id || 'nameTagPool';
                    
                    data.nameTags.push({
                        id: tag.id,
                        name: nameSpan ? nameSpan.textContent : '',
                        color: colorInput ? colorInput.value : '#e0e0e0',
                        parentId: parentId
                    });
                });
                
                // Capture all work items
                document.querySelectorAll('.work-item-row').forEach(row => {
                    const titleDiv = row.querySelector('.work-item-title');
                    const colorInput = row.querySelector('input[type="color"]');
                    const stages = [];
                    
                    row.querySelectorAll('.stage-content').forEach((stageContent, index) => {
                        const stageNames = ['first', 'double-check', 'final'];
                        const tagIds = Array.from(stageContent.querySelectorAll('.name-tag')).map(tag => tag.id);
                        stages.push({
                            name: stageNames[index],
                            tagIds: tagIds
                        });
                    });
                    
                    data.workItems.push({
                        id: row.id,
                        title: titleDiv ? titleDiv.textContent : '',
                        color: colorInput ? colorInput.value : '#ffffff',
                        stages: stages
                    });
                });
                
                return data;
            } catch (error) {
                console.error('状態キャプチャエラー:', error);
                return null;
            }
        }
        
        function addToUndoHistory() {
            const currentState = captureState();
            if (currentState) {
                undoHistory.push(currentState);
                // 履歴の上限を管理
                if (undoHistory.length > MAX_HISTORY) {
                    undoHistory.shift();
                }
                updateUndoButton();
            }
        }
        
        function undo() {
            if (undoHistory.length === 0) {
                alert('元に戻せる操作がありません');
                return;
            }
            
            const previousState = undoHistory.pop();
            restoreState(previousState);
            updateUndoButton();
            saveToLocalStorage();
        }
        
        function restoreState(data) {
            try {
                // Restore counters
                tagIdCounter = data.tagIdCounter || 0;
                workItemIdCounter = data.workItemIdCounter || 0;
                
                // Clear existing content
                document.getElementById('nameTagPool').innerHTML = '';
                document.getElementById('workItemsContainer').innerHTML = '';
                
                // Restore work items first (without triggering undo history)
                data.workItems.forEach(item => {
                    addWorkItemWithoutHistory(item.title, item.id);
                    const row = document.getElementById(item.id);
                    if (row) {
                        const colorInput = row.querySelector('input[type="color"]');
                        if (colorInput) {
                            colorInput.value = item.color;
                            row.style.backgroundColor = item.color;
                        }
                    }
                });
                
                // Restore name tags (without triggering undo history)
                data.nameTags.forEach(tagData => {
                    addNameTagWithoutHistory(tagData.name, tagData.id);
                    const tag = document.getElementById(tagData.id);
                    if (tag) {
                        const colorInput = tag.querySelector('input[type="color"]');
                        if (colorInput) {
                            colorInput.value = tagData.color;
                            tag.style.backgroundColor = tagData.color;
                        }
                        
                        // Move tag to correct location
                        if (tagData.parentId !== 'nameTagPool') {
                            const workItem = document.getElementById(tagData.parentId);
                            if (workItem) {
                                // Find the correct stage
                                const savedItem = data.workItems.find(item => item.id === tagData.parentId);
                                if (savedItem) {
                                    savedItem.stages.forEach((stage, index) => {
                                        if (stage.tagIds.includes(tagData.id)) {
                                            const stageContent = workItem.querySelectorAll('.stage-content')[index];
                                            if (stageContent) {
                                                stageContent.appendChild(tag);
                                            }
                                        }
                                    });
                                }
                            }
                        }
                    }
                });
                
                console.log('状態を復元しました');
            } catch (error) {
                console.error('復元エラー:', error);
            }
        }
        
        function updateUndoButton() {
            const undoBtn = document.getElementById('undoBtn');
            if (undoBtn) {
                undoBtn.disabled = undoHistory.length === 0;
            }
        }
        
        // --- Auto Save Functions ---
        function saveToLocalStorage() {
            try {
                const data = {
                    tagIdCounter: tagIdCounter,
                    workItemIdCounter: workItemIdCounter,
                    nameTags: [],
                    workItems: []
                };
                
                // Save all name tags
                document.querySelectorAll('.name-tag').forEach(tag => {
                    const nameSpan = tag.querySelector('span[contenteditable]');
                    const colorInput = tag.querySelector('input[type="color"]');
                    const parentId = tag.parentElement.id || tag.closest('.stage-content')?.parentElement?.parentElement?.id || 'nameTagPool';
                    
                    data.nameTags.push({
                        id: tag.id,
                        name: nameSpan ? nameSpan.textContent : '',
                        color: colorInput ? colorInput.value : '#e0e0e0',
                        parentId: parentId
                    });
                });
                
                // Save all work items
                document.querySelectorAll('.work-item-row').forEach(row => {
                    const titleDiv = row.querySelector('.work-item-title');
                    const colorInput = row.querySelector('input[type="color"]');
                    const stages = [];
                    
                    row.querySelectorAll('.stage-content').forEach((stageContent, index) => {
                        const stageNames = ['first', 'double-check', 'final'];
                        const tagIds = Array.from(stageContent.querySelectorAll('.name-tag')).map(tag => tag.id);
                        stages.push({
                            name: stageNames[index],
                            tagIds: tagIds
                        });
                    });
                    
                    data.workItems.push({
                        id: row.id,
                        title: titleDiv ? titleDiv.textContent : '',
                        color: colorInput ? colorInput.value : '#ffffff',
                        stages: stages
                    });
                });
                
                localStorage.setItem(STORAGE_KEY, JSON.stringify(data));
                console.log('データを保存しました');
            } catch (error) {
                console.error('保存エラー:', error);
            }
        }
        
        function loadFromLocalStorage() {
            try {
                const saved = localStorage.getItem(STORAGE_KEY);
                if (!saved) return false;
                
                const data = JSON.parse(saved);
                
                // Restore counters
                tagIdCounter = data.tagIdCounter || 0;
                workItemIdCounter = data.workItemIdCounter || 0;
                
                // Clear existing content
                document.getElementById('nameTagPool').innerHTML = '';
                document.getElementById('workItemsContainer').innerHTML = '';
                
                // Restore work items first
                data.workItems.forEach(item => {
                    addWorkItem(item.title);
                    const row = document.getElementById(item.id);
                    if (row) {
                        const colorInput = row.querySelector('input[type="color"]');
                        if (colorInput) {
                            colorInput.value = item.color;
                            row.style.backgroundColor = item.color;
                        }
                    }
                });
                
                // Restore name tags
                data.nameTags.forEach(tagData => {
                    addNameTag(tagData.name);
                    const tag = document.getElementById(tagData.id);
                    if (tag) {
                        const colorInput = tag.querySelector('input[type="color"]');
                        if (colorInput) {
                            colorInput.value = tagData.color;
                            tag.style.backgroundColor = tagData.color;
                        }
                        
                        // Move tag to correct location
                        if (tagData.parentId !== 'nameTagPool') {
                            const workItem = document.getElementById(tagData.parentId);
                            if (workItem) {
                                // Find the correct stage
                                const savedItem = data.workItems.find(item => item.id === tagData.parentId);
                                if (savedItem) {
                                    savedItem.stages.forEach((stage, index) => {
                                        if (stage.tagIds.includes(tagData.id)) {
                                            const stageContent = workItem.querySelectorAll('.stage-content')[index];
                                            if (stageContent) {
                                                stageContent.appendChild(tag);
                                            }
                                        }
                                    });
                                }
                            }
                        }
                    }
                });
                
                console.log('データを読み込みました');
                return true;
            } catch (error) {
                console.error('読み込みエラー:', error);
                return false;
            }
        }
        
        // Auto-save trigger
        function triggerAutoSave() {
            // Debounce to avoid excessive saves
            if (window.autoSaveTimeout) {
                clearTimeout(window.autoSaveTimeout);
            }
            window.autoSaveTimeout = setTimeout(saveToLocalStorage, 500);
        }

        // --- Drag and Drop Handlers ---
        function allowDrop(ev) {
            ev.preventDefault();
            ev.target.closest('.stage-content, .name-tag-container').classList.add('drag-over');
        }
        
        // Helper to remove drag-over class when leaving
        document.addEventListener('dragleave', function(ev) {
            if (ev.target.classList.contains('stage-content') || ev.target.classList.contains('name-tag-container')) {
                ev.target.classList.remove('drag-over');
            }
            // Check parents too just in case
             const dropZone = ev.target.closest('.stage-content, .name-tag-container');
             if (dropZone && !dropZone.contains(ev.relatedTarget)) {
                 dropZone.classList.remove('drag-over');
             }
        });

        function drag(ev) {
            ev.dataTransfer.setData("text/plain", ev.target.id);
            ev.target.classList.add('dragging');
        }
        
        function dragEnd(ev) {
            ev.target.classList.remove('dragging');
            // Clean up all drag-over classes
            document.querySelectorAll('.drag-over').forEach(el => el.classList.remove('drag-over'));
        }

        function drop(ev) {
            ev.preventDefault();
            const data = ev.dataTransfer.getData("text/plain");
            const draggedElement = document.getElementById(data);
            
            // Find the closest valid drop target
            let dropZone = ev.target.closest('.stage-content') || ev.target.closest('.name-tag-container');
            
            // If dropped directly on a name tag in the pool, use the pool container
            if (!dropZone && ev.target.classList.contains('name-tag')) {
                dropZone = ev.target.parentElement;
            }
            
            if (dropZone && draggedElement && draggedElement.classList.contains('name-tag')) {
                // Capture state before making changes
                addToUndoHistory();
                
                dropZone.classList.remove('drag-over');
                dropZone.appendChild(draggedElement);
                triggerAutoSave();
            }
        }

        // --- Reset Functionality ---
        function resetNameTags() {
            if (!confirm('すべての名札を初期位置に戻しますか？')) {
                return;
            }
            
            // Capture state before making changes
            addToUndoHistory();
            
            const pool = document.getElementById('nameTagPool');
            const allTags = document.querySelectorAll('.name-tag');
            
            allTags.forEach(tag => {
                pool.appendChild(tag);
            });
            triggerAutoSave();
        }

        function resetWorkItems() {
            if (!confirm('すべての作業項目を削除しますか？\n（名札はプールに戻ります）')) {
                return;
            }
            
            // Capture state before making changes
            addToUndoHistory();
            
            const pool = document.getElementById('nameTagPool');
            const rows = document.querySelectorAll('.work-item-row');
            
            rows.forEach(row => {
                // Rescue tags
                const tags = row.querySelectorAll('.name-tag');
                tags.forEach(tag => pool.appendChild(tag));
                // Remove row
                row.remove();
            });
            triggerAutoSave();
        }

        // --- Component Creation ---

        function createColorPicker(onChange) {
            const input = document.createElement('input');
            input.type = 'color';
            input.className = 'color-picker';
            input.value = '#e0e0e0';
            input.oninput = (e) => onChange(e.target.value);
            return input;
        }

        function addNameTag(name = "新しい名札") {
            // Capture state before adding
            addToUndoHistory();
            
            tagIdCounter++;
            const id = `tag-${tagIdCounter}`;
            
            const tag = document.createElement('div');
            tag.className = 'name-tag';
            tag.id = id;
            tag.draggable = true;
            tag.ondragstart = drag;
            tag.ondragend = dragEnd;
            
            // Color picker
            const colorInput = document.createElement('input');
            colorInput.type = 'color';
            colorInput.value = '#e0e0e0';
            colorInput.style.border = 'none';
            colorInput.style.width = '20px';
            colorInput.style.height = '20px';
            colorInput.style.cursor = 'pointer';
            colorInput.style.padding = '0';
            colorInput.style.background = 'none';
            colorInput.oninput = function(e) {
                tag.style.backgroundColor = e.target.value;
                triggerAutoSave();
            };
            
            // Editable Name (double-click to edit)
            const nameSpan = document.createElement('span');
            nameSpan.contentEditable = false;
            nameSpan.textContent = name;
            nameSpan.addEventListener('dblclick', function() {
                this.contentEditable = true;
                this.focus();
                // Select all text for easy editing
                const range = document.createRange();
                range.selectNodeContents(this);
                const selection = window.getSelection();
                selection.removeAllRanges();
                selection.addRange(range);
            });
            nameSpan.addEventListener('blur', function() {
                this.contentEditable = false;
                triggerAutoSave();
            });
            nameSpan.addEventListener('keydown', function(e) {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    this.blur();
                }
            });
            
            // Delete button
            const deleteBtn = document.createElement('span');
            deleteBtn.className = 'delete-btn';
            deleteBtn.textContent = '×';
            deleteBtn.onclick = function() {
                if(confirm('この名札を削除しますか？')) {
                    // Capture state before deletion
                    addToUndoHistory();
                    tag.remove();
                    triggerAutoSave();
                }
            };

            tag.appendChild(colorInput);
            tag.appendChild(nameSpan);
            tag.appendChild(deleteBtn);
            
            document.getElementById('nameTagPool').appendChild(tag);
            triggerAutoSave();
        }

        // Helper functions to add items without triggering undo history (for restore/load)
        function addNameTagWithoutHistory(name = "新しい名札", existingId = null) {
            if (existingId) {
                // Extract counter from existing ID
                const match = existingId.match(/tag-(\d+)/);
                if (match) {
                    const num = parseInt(match[1]);
                    if (num >= tagIdCounter) {
                        tagIdCounter = num;
                    }
                }
            } else {
                tagIdCounter++;
            }
            const id = existingId || `tag-${tagIdCounter}`;
            
            const tag = document.createElement('div');
            tag.className = 'name-tag';
            tag.id = id;
            tag.draggable = true;
            tag.ondragstart = drag;
            tag.ondragend = dragEnd;
            
            // Color picker
            const colorInput = document.createElement('input');
            colorInput.type = 'color';
            colorInput.value = '#e0e0e0';
            colorInput.style.border = 'none';
            colorInput.style.width = '20px';
            colorInput.style.height = '20px';
            colorInput.style.cursor = 'pointer';
            colorInput.style.padding = '0';
            colorInput.style.background = 'none';
            colorInput.oninput = function(e) {
                tag.style.backgroundColor = e.target.value;
                triggerAutoSave();
            };
            
            // Editable Name
            const nameSpan = document.createElement('span');
            nameSpan.contentEditable = false;
            nameSpan.textContent = name;
            nameSpan.addEventListener('dblclick', function() {
                this.contentEditable = true;
                this.focus();
                const range = document.createRange();
                range.selectNodeContents(this);
                const selection = window.getSelection();
                selection.removeAllRanges();
                selection.addRange(range);
            });
            nameSpan.addEventListener('blur', function() {
                this.contentEditable = false;
                triggerAutoSave();
            });
            nameSpan.addEventListener('keydown', function(e) {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    this.blur();
                }
            });
            
            // Delete button
            const deleteBtn = document.createElement('span');
            deleteBtn.className = 'delete-btn';
            deleteBtn.textContent = '×';
            deleteBtn.onclick = function() {
                if(confirm('この名札を削除しますか？')) {
                    addToUndoHistory();
                    tag.remove();
                    triggerAutoSave();
                }
            };

            tag.appendChild(colorInput);
            tag.appendChild(nameSpan);
            tag.appendChild(deleteBtn);
            
            document.getElementById('nameTagPool').appendChild(tag);
        }
        
        function addWorkItem(title = "新しい作業項目") {
            // Capture state before adding
            addToUndoHistory();
            
            workItemIdCounter++;
            const id = `work-item-${workItemIdCounter}`;
            addWorkItemWithoutHistory(title, id);
        }
        
        function addWorkItemWithoutHistory(title = "新しい作業項目", existingId = null) {
            if (existingId) {
                // Extract counter from existing ID
                const match = existingId.match(/work-item-(\d+)/);
                if (match) {
                    const num = parseInt(match[1]);
                    if (num >= workItemIdCounter) {
                        workItemIdCounter = num;
                    }
                }
            } else {
                workItemIdCounter++;
            }
            const id = existingId || `work-item-${workItemIdCounter}`;
            
            const container = document.getElementById('workItemsContainer');
            const row = document.createElement('div');
            row.className = 'work-item-row';
            row.id = id;

            // Controls (Up/Down/Delete)
            const controlsDiv = document.createElement('div');
            controlsDiv.className = 'row-controls';
            
            const upBtn = document.createElement('button');
            upBtn.className = 'row-btn';
            upBtn.innerHTML = '▲';
            upBtn.title = '上に移動';
            upBtn.onclick = () => moveRow(row, -1);
            
            const downBtn = document.createElement('button');
            downBtn.className = 'row-btn';
            downBtn.innerHTML = '▼';
            downBtn.title = '下に移動';
            downBtn.onclick = () => moveRow(row, 1);
            
            const delBtn = document.createElement('button');
            delBtn.className = 'row-btn';
            delBtn.innerHTML = '×';
            delBtn.style.color = 'red';
            delBtn.title = '削除';
            delBtn.onclick = () => {
                if(confirm('この作業項目を削除しますか？')) {
                    // Capture state before deletion
                    addToUndoHistory();
                    const tags = row.querySelectorAll('.name-tag');
                    const pool = document.getElementById('nameTagPool');
                    tags.forEach(tag => pool.appendChild(tag));
                    row.remove();
                    triggerAutoSave();
                }
            };

            controlsDiv.appendChild(upBtn);
            controlsDiv.appendChild(downBtn);
            controlsDiv.appendChild(delBtn);
            
            // Color strip for row grouping visual
            const colorStrip = document.createElement('input');
            colorStrip.type = 'color';
            colorStrip.value = '#ffffff';
            colorStrip.style.width = '20px';
            colorStrip.style.height = '40px';
            colorStrip.style.border = 'none';
            colorStrip.style.padding = '0';
            colorStrip.style.background = 'none';
            colorStrip.style.cursor = 'pointer';
            colorStrip.title = '背景色を変更';
            colorStrip.oninput = (e) => {
                row.style.backgroundColor = e.target.value;
                triggerAutoSave();
            };

            // Title
            const titleDiv = document.createElement('div');
            titleDiv.className = 'work-item-title';
            titleDiv.contentEditable = true;
            titleDiv.textContent = title;
            titleDiv.addEventListener('blur', triggerAutoSave);
            titleDiv.addEventListener('keydown', function(e) {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    this.blur();
                }
            });

            // Stages Container
            const stagesContainer = document.createElement('div');
            stagesContainer.className = 'stages-container';

            // Stages
            const stages = [
                { name: '一次作業', id: 'first' },
                { name: 'ダブルチェック', id: 'double-check' },
                { name: '最終確認', id: 'final' }
            ];

            stages.forEach((stageInfo, index) => {
                const stageDiv = document.createElement('div');
                stageDiv.className = 'stage';
                
                const stageHeader = document.createElement('div');
                stageHeader.className = 'stage-header';
                stageHeader.textContent = stageInfo.name;
                
                const stageContent = document.createElement('div');
                stageContent.className = 'stage-content';
                stageContent.ondrop = drop;
                stageContent.ondragover = allowDrop;
                
                stageDiv.appendChild(stageHeader);
                stageDiv.appendChild(stageContent);
                stagesContainer.appendChild(stageDiv);

                // Add arrow if not last
                if (index < stages.length - 1) {
                    const arrow = document.createElement('div');
                    arrow.className = 'arrow';
                    arrow.innerHTML = '→';
                    stagesContainer.appendChild(arrow);
                }
            });

            row.appendChild(controlsDiv);
            row.appendChild(colorStrip);
            row.appendChild(titleDiv);
            row.appendChild(stagesContainer);

            container.appendChild(row);
            triggerAutoSave();
        }

        function moveRow(row, direction) {
            // Capture state before moving
            addToUndoHistory();
            
            const container = document.getElementById('workItemsContainer');
            if (direction === -1) {
                if (row.previousElementSibling) {
                    container.insertBefore(row, row.previousElementSibling);
                    triggerAutoSave();
                }
            } else {
                if (row.nextElementSibling) {
                    container.insertBefore(row, row.nextElementSibling.nextElementSibling);
                    triggerAutoSave();
                }
            }
        }

        // --- Initialization ---
        window.onload = function() {
            // Try to load saved data
            const loaded = loadFromLocalStorage();
            
            // If no saved data, add initial demo data
            if (!loaded) {
                // Clear undo history during initial load
                undoHistory.length = 0;
                
                addNameTag("佐藤");
                addNameTag("鈴木");
                addNameTag("田中");
                
                addWorkItem("ホームページ更新");
                addWorkItem("バグ修正 #102");
                
                // Save initial state
                saveToLocalStorage();
                
                // Clear undo history after initial setup
                undoHistory.length = 0;
            }
            
            // Update undo button state
            updateUndoButton();
        };

    </script>
</body>
</html>
